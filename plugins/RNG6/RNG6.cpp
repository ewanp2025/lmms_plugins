#include "RNG6.h"#include "AudioEngine.h"#include "Engine.h"#include "InstrumentTrack.h"#include "NotePlayHandle.h"#include "lmms_math.h"#include "embed.h"#include "plugin_export.h"#include <QPainter>#include <QPainterPath>#include <QTimer>#include <cmath>namespace lmms {extern "C" {    Plugin::Descriptor PLUGIN_EXPORT RNG6_plugin_descriptor = {        "RNG6", "RNG6", QT_TRANSLATE_NOOP("PluginBrowser", "Deterministic Chaos Synth"),        "Ewan", 0x0100, Plugin::Type::Instrument, new PluginPixmapLoader("logo"), nullptr, nullptr    };}class DeterministicRandom {public:    DeterministicRandom(long seed) : state(seed) {}    float next() {        state = (state * 1103515245 + 12345) % 2147483648;        return (float)state / 2147483648.0f;    }    float nextBipolar() { return (next() * 2.0f) - 1.0f; }private:    long state;};// --- ChaosVoice Implementation ---ChaosVoice::ChaosVoice(std::shared_ptr<const ChaosPatch> patch, NotePlayHandle* _nph, const sample_rate_t _sample_rate, float _chaosAmt, float _masterCutoff, float _masterRes, int _activeVoices, float _masterSpread, float _envA, float _envD, float _envS, float _envR, float _lfoSpeed) :    m_patch(patch), m_nph(_nph), m_sampleRate(_sample_rate), m_chaosAmount(_chaosAmt), m_cutoff(_masterCutoff), m_res(_masterRes), m_numVoices(_activeVoices), m_spread(_masterSpread), m_lfoSpeed(_lfoSpeed), m_envA(_envA), m_envD(_envD), m_envS(_envS), m_envR(_envR){    m_filterStateL[0] = m_filterStateL[1] = m_filterStateR[0] = m_filterStateR[1] = 0.0f;    m_lfoPhase = 0.0f;    m_adsr.trigger();    m_voiceStates.resize(m_numVoices);    for(int i=0; i < m_numVoices; ++i) {        m_voiceStates[i].phase = 0.0f;        float finalPan = std::clamp(((m_numVoices > 1) ? ((float)i / (float)(m_numVoices - 1)) * 2.0f - 1.0f : 0.0f) * m_spread + (m_patch->voices[i].pan * m_chaosAmount), -1.0f, 1.0f);        m_voiceStates[i].currentPanL = std::cos((finalPan + 1.0f) * 0.785398f);        m_voiceStates[i].currentPanR = std::sin((finalPan + 1.0f) * 0.785398f);    }}float ChaosVoice::getModulation(float phase) {    float idx = phase * 1023.0f; int i0 = (int)idx; int i1 = (i0 + 1) % 1024;    return m_patch->modulationCurve[i0] * (1.0f - (idx - i0)) + m_patch->modulationCurve[i1] * (idx - i0);}float ChaosVoice::getOscillator(float phase, float shape, float fm) {    float p = phase + (std::sin(phase * 25.132f) * fm * 0.3f); p -= std::floor(p);    if (shape < 0.5f) {        float morph = shape * 2.0f;        return ((p * 2.0f) - 1.0f) * (1.0f - morph) + ((p < 0.5f) ? 1.0f : -1.0f) * morph;    }    float morph = (shape - 0.5f) * 2.0f;    return ((p < 0.5f) ? 1.0f : -1.0f) * (1.0f - morph) + (((float)((int)(p * 12345.0f) % 100) / 50.0f) - 1.0f) * morph;}void ChaosVoice::nextSample(float* outL, float* outR) {    float env = m_adsr.process(m_envA, m_envD, m_envS, m_envR, m_sampleRate);    m_lfoPhase = std::fmod(m_lfoPhase + (m_lfoSpeed / m_sampleRate), 1.0f);    float baseFreq = m_nph->frequency(), sumL = 0, sumR = 0;    for (int i=0; i < (int)m_voiceStates.size(); ++i) {        m_voiceStates[i].phase = std::fmod(m_voiceStates[i].phase + (baseFreq * std::pow(2.0f, m_patch->voices[i].detune * m_chaosAmount * 0.1f)) / m_sampleRate, 1.0f);        float sig = getOscillator(m_voiceStates[i].phase, std::clamp(m_patch->voices[i].shape * m_chaosAmount, 0.0f, 1.0f), m_patch->voices[i].fmAmount * m_chaosAmount);        sumL += sig * m_voiceStates[i].currentPanL; sumR += sig * m_voiceStates[i].currentPanR;    }    float f = std::sin(3.14159f * std::clamp(m_cutoff + (env * 0.5f) + ((getModulation(m_lfoPhase) - 0.5f) * m_chaosAmount * 0.3f), 0.01f, 0.99f) * 0.45f);    m_filterStateL[0] += f * (sumL * (1.0f / std::sqrt((float)m_voiceStates.size())) - m_filterStateL[0] - m_res * m_filterStateL[0]);    m_filterStateR[0] += f * (sumR * (1.0f / std::sqrt((float)m_voiceStates.size())) - m_filterStateR[0] - m_res * m_filterStateR[0]);    *outL = m_filterStateL[0] * env; *outR = m_filterStateR[0] * env;}// --- RNG6Instrument Implementation ---RNG6Instrument::RNG6Instrument(InstrumentTrack* t) : Instrument(t, &RNG6_plugin_descriptor),    m_seed(500.0f, 0.0f, 9999.0f, 1.0f, this, tr("Seed")), m_chaosAmount(1.0f, 0.0f, 1.0f, 0.01f, this, tr("Chaos")),    m_lockPitch(false, this, tr("Lock Pitch")), m_lockFilter(false, this, tr("Lock Filter")), m_lockShape(false, this, tr("Lock Shape")),    m_uniVoices(1.0f, 1.0f, 6.0f, 1.0f, this, tr("Voices")), m_uniSpread(0.5f, 0.0f, 1.0f, 0.01f, this, tr("Spread")),    m_filterCutoff(0.5f, 0.0f, 1.0f, 0.01f, this, tr("Cutoff")), m_filterRes(0.2f, 0.0f, 1.0f, 0.01f, this, tr("Res")), m_gain(0.8f, 0.0f, 1.0f, 0.01f, this, tr("Vol")),    m_envA(0.01f, 0.0f, 2.0f, 0.01f, this, tr("Att")), m_envD(0.4f, 0.0f, 2.0f, 0.01f, this, tr("Dec")), m_envS(0.5f, 0.0f, 1.0f, 0.01f, this, tr("Sus")), m_envR(0.4f, 0.0f, 3.0f, 0.01f, this, tr("Rel")), m_lfoSpeed(5.0f, 0.1f, 20.0f, 0.1f, this, tr("Rate")){    m_currentPatch = std::make_shared<ChaosPatch>(); updateSeed();    connect(&m_seed, SIGNAL(dataChanged()), this, SLOT(updateSeed()));}void RNG6Instrument::updateSeed() {    auto newPatch = std::make_shared<ChaosPatch>(); DeterministicRandom rng((long)m_seed.value());    for(int i=0; i<6; ++i) {        newPatch->voices[i].detune = (m_lockPitch.value() && m_currentPatch) ? m_currentPatch->voices[i].detune : rng.nextBipolar();        newPatch->voices[i].cutoffOffset = (m_lockFilter.value() && m_currentPatch) ? m_currentPatch->voices[i].cutoffOffset : rng.nextBipolar();        newPatch->voices[i].resOffset = (m_lockFilter.value() && m_currentPatch) ? m_currentPatch->voices[i].resOffset : rng.next();        newPatch->voices[i].shape = (m_lockShape.value() && m_currentPatch) ? m_currentPatch->voices[i].shape : rng.next();        newPatch->voices[i].fmAmount = (m_lockShape.value() && m_currentPatch) ? m_currentPatch->voices[i].fmAmount : rng.next();        newPatch->voices[i].pan = rng.nextBipolar();    }    for(int i=0; i<1024; ++i) newPatch->modulationCurve[i] = rng.next();    std::atomic_store(&m_currentPatch, newPatch);}void RNG6Instrument::playNote(NotePlayHandle* _n, SampleFrame* _working_buffer) {    if (!_n->m_pluginData) _n->m_pluginData = new ChaosVoice(m_currentPatch, _n, Engine::audioEngine()->outputSampleRate(), m_chaosAmount.value(), m_filterCutoff.value(), m_filterRes.value(), (int)m_uniVoices.value(), m_uniSpread.value(), m_envA.value(), m_envD.value(), m_envS.value(), m_envR.value(), m_lfoSpeed.value());    auto synth = static_cast<ChaosVoice*>(_n->m_pluginData);    if (_n->isReleased()) synth->release();    for(fpp_t frame = _n->noteOffset(); frame < _n->framesLeftForCurrentPeriod() + _n->noteOffset(); ++frame) {        float L, R; synth->nextSample(&L, &R);        _working_buffer[frame] = SampleFrame(L * m_gain.value(), R * m_gain.value());    }    applyRelease(_working_buffer, _n);}void RNG6Instrument::deleteNotePluginData(NotePlayHandle* _n) { delete static_cast<ChaosVoice*>(_n->m_pluginData); }void RNG6Instrument::saveSettings(QDomDocument& d, QDomElement& p) { p.setAttribute("version", "1.1"); m_seed.saveSettings(d, p, "seed"); m_chaosAmount.saveSettings(d, p, "chaos"); m_lockPitch.saveSettings(d, p, "l_pitch"); m_lockFilter.saveSettings(d, p, "l_filter"); m_lockShape.saveSettings(d, p, "l_shape"); m_uniVoices.saveSettings(d, p, "voices"); m_uniSpread.saveSettings(d, p, "spread"); m_filterCutoff.saveSettings(d, p, "cutoff"); m_filterRes.saveSettings(d, p, "res"); m_gain.saveSettings(d, p, "gain"); m_envA.saveSettings(d, p, "env_a"); m_envD.saveSettings(d, p, "env_d"); m_envS.saveSettings(d, p, "env_s"); m_envR.saveSettings(d, p, "env_r"); m_lfoSpeed.saveSettings(d, p, "lfo_speed"); }void RNG6Instrument::loadSettings(const QDomElement& p) { m_seed.loadSettings(p, "seed"); m_chaosAmount.loadSettings(p, "chaos"); m_lockPitch.loadSettings(p, "l_pitch"); m_lockFilter.loadSettings(p, "l_filter"); m_lockShape.loadSettings(p, "l_shape"); m_uniVoices.loadSettings(p, "voices"); m_uniSpread.loadSettings(p, "spread"); m_filterCutoff.loadSettings(p, "cutoff"); m_filterRes.loadSettings(p, "res"); m_gain.loadSettings(p, "gain"); m_envA.loadSettings(p, "env_a"); m_envD.loadSettings(p, "env_d"); m_envS.loadSettings(p, "env_s"); m_envR.loadSettings(p, "env_r"); m_lfoSpeed.loadSettings(p, "lfo_speed"); updateSeed(); }QString RNG6Instrument::nodeName() const { return RNG6_plugin_descriptor.name; }gui::PluginView* RNG6Instrument::instantiateView(QWidget* p) { return new gui::RNG6View(this, p); }// --- GUI Implementation ---namespace gui {void ChaosVisualizer::paintEvent(QPaintEvent*) {    QPainter p(this);    p.setRenderHint(QPainter::Antialiasing);    p.fillRect(rect(), QColor(10, 15, 10));     // Vintage Oscilloscope Grid    p.setPen(QPen(QColor(30, 45, 30), 1));    for(int x = 0; x < width(); x += 40) p.drawLine(x, 0, x, height());    for(int y = 0; y < height(); y += 20) p.drawLine(0, y, width(), y);       if (!m_patch) return;    float step = (float)width() / 1024.0f;    QPainterPath path;    path.moveTo(0, height() - (m_patch->modulationCurve[0] * height()));    for (int i = 1; i < 1024; ++i) {        path.lineTo(i * step, height() - (m_patch->modulationCurve[i] * height()));    }    // Phosphor Glow Layers    p.setPen(QPen(QColor(0, 255, 120, 40), 5)); p.drawPath(path);    p.setPen(QPen(QColor(0, 255, 150, 80), 3)); p.drawPath(path);    // Main Beam with flicker    int flicker = (std::rand() % 30);     p.setPen(QPen(QColor(180, 255, 200, 200 + flicker), 1.2));     p.drawPath(path);}RNG6View::RNG6View(Instrument* i, QWidget* p) : InstrumentViewFixedSize(i, p), m_currentTab(0) {    setFixedSize(250, 240);     QString tabStyle = "QPushButton { background: #444; color: #AAA; border: 1px solid #222; } QPushButton:checked { background: #666; color: #FFF; border-bottom: 2px solid #F80; }";        m_btnTabMain = new QPushButton("SEED", this); m_btnTabMain->setGeometry(5,5,118,20); m_btnTabMain->setCheckable(true); m_btnTabMain->setChecked(true); m_btnTabMain->setStyleSheet(tabStyle);    m_btnTabSettings = new QPushButton("TWEAK", this); m_btnTabSettings->setGeometry(127,5,118,20); m_btnTabSettings->setCheckable(true); m_btnTabSettings->setStyleSheet(tabStyle);       connect(m_btnTabMain, &QPushButton::clicked, this, &RNG6View::showPageMain);    connect(m_btnTabSettings, &QPushButton::clicked, this, &RNG6View::showPageSettings);    m_visualizer = new ChaosVisualizer(this); m_visualizer->setGeometry(20, 75, 210, 40);     // --- MAIN TAB ---    m_seedKnob = new Knob(this, tr("ID")); m_seedKnob->move(40, 30);    m_chaosKnob = new Knob(this, tr("Chaos")); m_chaosKnob->move(160, 30);    m_btnLockPitch = new LedCheckBox(tr("Lock Ptch"), this, tr("Lock Pitch"), LedCheckBox::LedColor::Red); m_btnLockPitch->move(20, 125);    m_btnLockShape = new LedCheckBox(tr("Lock Shp"), this, tr("Lock Shape"), LedCheckBox::LedColor::Yellow); m_btnLockShape->move(100, 125);    m_btnLockFilter = new LedCheckBox(tr("Lock Flt"), this, tr("Lock Filter"), LedCheckBox::LedColor::Green); m_btnLockFilter->move(180, 125);    m_cutoffKnob = new Knob(this, tr("Cutoff")); m_cutoffKnob->move(60, 170);    m_resKnob = new Knob(this, tr("Res")); m_resKnob->move(130, 170);    // --- TWEAK TAB ---    m_voicesKnob = new Knob(this, tr("Voices")); m_voicesKnob->move(20, 40);    m_spreadKnob = new Knob(this, tr("Spread")); m_spreadKnob->move(85, 40);    m_gainKnob = new Knob(this, tr("Volume")); m_gainKnob->move(150, 40);       m_envAKnob = new Knob(this, tr("Attack")); m_envAKnob->move(20, 110);    m_envDKnob = new Knob(this, tr("Decay")); m_envDKnob->move(75, 110);    m_envSKnob = new Knob(this, tr("Sustain")); m_envSKnob->move(130, 110);    m_envRKnob = new Knob(this, tr("Release")); m_envRKnob->move(185, 110);    m_refreshTimer = new QTimer(this);     connect(m_refreshTimer, &QTimer::timeout, this, &RNG6View::refreshVisualizer);     m_refreshTimer->start(50);    updateVisibleWidgets();}void RNG6View::showPageMain() { m_currentTab = 0; m_btnTabMain->setChecked(true); m_btnTabSettings->setChecked(false); updateVisibleWidgets(); }void RNG6View::showPageSettings() { m_currentTab = 1; m_btnTabMain->setChecked(false); m_btnTabSettings->setChecked(true); updateVisibleWidgets(); }void RNG6View::refreshVisualizer() { auto inst = castModel<RNG6Instrument>(); if (inst) m_visualizer->setPatch(inst->currentPatch()); }void RNG6View::updateVisibleWidgets() {     bool main = (m_currentTab == 0), set = (m_currentTab == 1);     m_visualizer->setVisible(main); m_seedKnob->setVisible(main); m_chaosKnob->setVisible(main);     m_btnLockPitch->setVisible(main); m_btnLockFilter->setVisible(main); m_btnLockShape->setVisible(main);     m_cutoffKnob->setVisible(main); m_resKnob->setVisible(main);     m_voicesKnob->setVisible(set); m_spreadKnob->setVisible(set); m_gainKnob->setVisible(set);     m_envAKnob->setVisible(set); m_envDKnob->setVisible(set); m_envSKnob->setVisible(set); m_envRKnob->setVisible(set); }void RNG6View::modelChanged() {     auto p = castModel<RNG6Instrument>();     m_seedKnob->setModel(&p->m_seed); m_chaosKnob->setModel(&p->m_chaosAmount);     m_btnLockPitch->setModel(&p->m_lockPitch); m_btnLockFilter->setModel(&p->m_lockFilter);     m_btnLockShape->setModel(&p->m_lockShape); m_cutoffKnob->setModel(&p->m_filterCutoff);     m_resKnob->setModel(&p->m_filterRes); m_voicesKnob->setModel(&p->m_uniVoices);     m_spreadKnob->setModel(&p->m_uniSpread); m_gainKnob->setModel(&p->m_gain);     m_envAKnob->setModel(&p->m_envA); m_envDKnob->setModel(&p->m_envD);     m_envSKnob->setModel(&p->m_envS); m_envRKnob->setModel(&p->m_envR); }} // namespace guiextern "C" {    PLUGIN_EXPORT Plugin* lmms_plugin_main(Model* m, void*) {        return new RNG6Instrument(static_cast<InstrumentTrack*>(m));    }}} // namespace lmms